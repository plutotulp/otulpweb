#+TITLE: www.otulp.net
#+OPTIONS: ^:{} toc:nil

* Overview
  Server and client code for the www.otulp.net web site.

  Client in this case basically means the web site contents. The idea
  is that the server supplies the client code at the root path, and
  otherwise acts as an API server for the client.

  In practice, the client has no need for the server for now; the
  server basically does nothing. What you get at https://www.otulp.net
  is just the client served by nginx.

* Prerequisites
  - Nix :: Get it at https://nixos.org
  - Cachix :: An binary cache (https://cachix.org) that lets us avoid
    compiling GHCJS from scratch (or, as is usually the case: try to
    compile and run out of memory).
  - GNU make :: The build tool that was too simplistic, twisted into
    something that still doesn't fit modern demands.

  Well, nix can of course provide the latter two.

* Build
  Enable =miso= =cachix= cache. May need additional configuration that
  I don't remember anymore.

  #+begin_src shell
    cachix use miso
  #+end_src

  Build both =server= and =webclient= code in the =build= directory,
  using =nix=.

  #+begin_src shell
    make
  #+end_src

* Development builds
  During client development, it is sure nice to be able to iterate a
  bit faster than GHCJS allows for. The =SOMETHING-dev-ghcid= PHONY
  targes run a ghcid session with the normal GHC compiler and
  hlint. This makes it possible to verify that code compiles, quickly
  recompiling when code changes.

  #+begin_src shell
    # work on client code
    make webclient-ghcid

    # work on common code
    make common-ghcid

    # work on common code tests
    make common-ghcid-tasty
  #+end_src

  All the above will tell you if code compiles, and provide linting,
  but will not *run* the code. To build a release version of the
  webclient and serve it locally, use a special PHONY target:

  #+begin_src shell
    # ad-hoc server listens at http://localhost:3000.
    make webclient-dev-server
  #+end_src

  Note that this does *not* use otulpweb-server, but rather just
  builds otulpweb-webclient and serves the static js and html files
  with wai-app-static. This is because otulpweb-server is not ready
  for use yet.

* Tasks remaining [0/2]

** TODO Database library
   Somme Contenders:
   - hasql :: Nikita Volkov. Claims to be fast. I *think* it comes
     with migrations support. Supports only Postgresql, I think.
   - beam :: Looks fancy. Supports multiple primary keys, yey!
     Migrations. Seems a bit like the esqelito (or whatever it's
     called), but more capable? Supports Sqlite and Postresql, maybe
     more. Has [[https://haskell-beam.github.io/beam/][nice docs]]!
   - persistent :: Popular, I think? Weird primary key demands, I seem
     to recall. I thnk there's some migration strategy. Pairs with
     esqueleto (or whatever it's called) for typed queries, but I
     remember these becoming unwieldy. Supports at least Sqlite and
     Postgres, maybe more.

** TODO Data dir
   Should probably make default.nix' otulpweb-service setup a var
   directory as well, and put a sqlite db there. Or maybe use
   postgresql. Either, way, storage is next.

** TODO Authentication?
   This can probably wait. For the Meter app, I could perhaps extract
   a unique ID from your web client / phone and just key data by that?
   Or you choose your own username, and we keep it in the browser's
   local storage as long as possible? Could just make sure to store
   enough metadata along with the metrics to possibly filter out any
   rogue data afterwards. Key thing for Meter: must be super easy to
   register metrics!
